# Part 3. 업무에 꼭 필요한 AI 고급 활용

## Agent에 대해 알아보자

이제 우리는 단순히 “AI를 쓰는 개발자”가 아니라  
**AI에게 일을 맡기는 개발자**가 되어야 합니다.

Part 2에서 Cursor를 통해 AI 주도 개발 환경을 구성했다면,  
Part 3에서는 그 중심에 있는 개념인 **Agent**를 깊이 있게 이해합니다.

---

### Agent란 무엇인가 (Model, Instructions, Tools)

#### 우리가 떠올리는 Agent의 이미지

많은 사람들이 Agent를 떠올리면  
영화 *아이언맨*의 **J.A.R.V.I.S**를 생각합니다.

- 말을 알아듣고
- 상황을 파악하고
- 필요한 정보를 찾고
- 스스로 판단해 행동하는 존재

이 이미지는 과장처럼 보이지만,  
현재 우리가 사용하는 AI Agent의 개념과 크게 다르지 않습니다.

---

#### OpenAI가 정의하는 Agent

OpenAI는 Agent를 다음과 같이 정의합니다.

> **Agents are systems that independently accomplish tasks on your behalf.**

즉, Agent는:
- 단순히 질문에 답하는 존재가 아니라
- 사용자의 **목표를 대신 달성**하는 시스템입니다.

이를 가능하게 하는 핵심 요소는 3가지입니다.

---

#### Agent를 구성하는 3요소

1️⃣ **Model**
- 추론과 판단을 담당하는 두뇌
- GPT, Claude, Gemini 등

2️⃣ **Instructions**
- Agent가 따라야 할 규칙과 가드레일
- “어떻게 행동해야 하는가”

3️⃣ **Tools**
- Agent가 실제 행동을 할 수 있게 해주는 수단
- 파일 수정, 검색, API 호출, 명령 실행 등

이 3요소가 결합되면,
AI는 더 이상 “대화 상대”가 아니라  
**작업을 수행하는 주체**가 됩니다.

---

### Agent에게 규칙(Instruction)을 부여하는 방법  
### – 개발 Prompt 작성하는 방법

Agent에게 일을 맡기기 위해 가장 먼저 해야 할 일은  
**명확한 Instruction을 제공하는 것**입니다.

실무에 비유하면,
> 막 입사한 신입 개발자에게  
> “알아서 잘 해봐”라고 말하는 것과 같습니다.

---

#### Instruction을 WHY / HOW / WHAT으로 나누기

좋은 Instruction은 다음 구조를 가집니다.

##### WHY – 왜 이 일을 하는가
- Agent의 역할 정의
- 목표와 책임 범위
- 하지 말아야 할 것

##### HOW – 어떻게 일을 진행해야 하는가
- Workflow
- Tool 사용 규칙
- 검토 기준

##### WHAT – 지금 당장 할 일
- 구체적인 작업 요청
- 수정 대상, 결과물 형태

---

#### Instruction 구조의 계층

Agent는 하나의 Prompt만으로 동작하지 않습니다.

다음과 같은 계층 구조로 Instruction이 누적됩니다.

- **System Prompt**
- **User Rules**
- **Project Rules**
- **User Prompt**

이 구조를 이해하지 못하면:
- 왜 같은 Prompt인데 결과가 달라지는지
- 왜 Agent가 말을 안 듣는지

설명할 수 없습니다.

---

### Agent의 System Prompt 톺아보기  
### – Context 힌트 알아보기

#### 왜 System Prompt를 봐야 하는가?

System Prompt에는  
**Agent의 행동 전략과 우선순위**가 담겨 있습니다.

- 어떤 정보를 더 중요하게 보는가
- Tool을 언제 호출하는가
- 안전 가드레일은 무엇인가

즉,
> System Prompt = Agent의 헌법

---

#### Cursor Agent의 특징

Cursor는 명시적으로 System Prompt를 보여주지 않지만,
다음 요소들이 그 역할을 분담합니다.

- Rules (User / Project)
- Codebase Indexing
- Memory
- MCP Tool 설정

이것이 바로
> **Cursor를 단순 IDE가 아니라 Agent 플랫폼으로 봐야 하는 이유**입니다.

---

### Agent가 Tools를 활용하는 방법

#### Tool이란 무엇인가?

Agent에게 Tool은  
사람에게는 **손, 눈, 입**과 같은 존재입니다.

- 파일을 읽고
- 코드를 수정하고
- 외부 시스템과 상호작용

Tool이 없다면 Agent는  
“말만 잘하는 컨설턴트”에 불과합니다.

---

#### Tool 사용의 핵심 원칙

Agent는 다음 순서로 Tool을 사용합니다.

1. 목표 이해
2. 필요한 정보 판단
3. 적절한 Tool 선택
4. 결과를 다시 추론에 반영

이 과정이 반복되며  
**계획 → 실행 → 검토**가 이루어집니다.

---

#### MCP(Model Context Protocol)의 의미

MCP는
> “Agent가 외부 세계와 연결되는 표준 인터페이스”

라고 이해하면 됩니다.

- Notion
- Linear
- DB
- 사내 문서
- 커스텀 스크립트

이 모든 것을 **Agent의 도구 상자**로 만들 수 있습니다.

---

### Agent의 Memory에 대해

#### AI는 왜 자꾸 잊어버릴까?

AI는 인간처럼 기억하지 않습니다.

- Context Window 한계
- 이전 대화는 점점 밀려남
- 장기 기억이 기본적으로 없음

그래서 실무에서 자주 이런 상황이 발생합니다.

> “어제 설명한 거 다시 말해줘야 하나요…?”

---

#### Agent에게 Memory가 필요한 이유

Agent가 일을 잘하려면:
- 프로젝트 맥락
- 이전 결정
- 작업 이력

을 **지속적으로 유지**해야 합니다.

이를 위해 등장한 개념이 **Memory**입니다.

---

#### Memory의 종류

- **Short-term Memory**
  - 현재 작업 맥락
- **Long-term Memory**
  - 프로젝트 정의
  - Workflow
  - 히스토리 요약

Cursor, Cline과 같은 도구는  
이 Memory를 **파일, 규칙, 요약** 형태로 관리합니다.

---

### 당신은 Claude Sonnet 4로 구동되는 AI 코딩 어시스턴트입니다

이 문장은 단순한 모델 지정 문장이 아닙니다.

이 한 줄에는 다음 의미가 담겨 있습니다.

- 어떤 성향의 추론을 기대하는지
- 코드 품질과 설명 수준
- 안정성과 창의성의 균형

즉,
> **Model 선택도 Instruction의 일부**입니다.

---

### 이 섹션의 핵심 정리

- Agent는 “대화하는 AI”가 아니다
- Agent는 목표를 대신 달성하는 시스템이다
- Model / Instructions / Tools가 결합되어야 한다
- Instruction은 WHY / HOW / WHAT 구조로 설계한다
- Memory 없이는 실무 Agent는 성립하지 않는다
- Cursor는 이미 Agent 플랫폼이다

## 나 대신 Cursor가 일을 잘하게 만드는 방법

Agent를 이해했다고 해서  
자동으로 AI가 일을 잘해주는 것은 아닙니다.

AI는 스스로 “일을 잘하는 방식”을 만들어내지 않습니다.  
반드시 **사람이 하던 일을 구조로 만들어 넘겨줘야** 합니다.

이 섹션의 목표는 명확합니다.

> **“내가 하던 업무를 Cursor Agent가 대신 수행하게 만든다”**

---

### 내가 일하는 방식을 분해하자 (Workflow 구성하기)

#### 우리는 이미 Workflow를 가지고 있다

개발자는 매일 같은 일을 반복합니다.

- 요구사항을 읽고
- 구조를 생각하고
- 코드를 작성하고
- 테스트하고
- 문서를 남깁니다

다만 이 Workflow는:
- 머릿속에만 있고
- 문서로 정리되지 않았고
- 사람에게만 최적화되어 있습니다

AI에게 일을 맡기려면  
**암묵지(暗默知)를 명시지(明示知)로 바꿔야 합니다.**

---

#### Workflow 분해 예시 (백엔드 API 개발)

1. 요구사항 요약
2. API 스펙 정의
3. 보안 포인트 체크
4. 코드 구현
5. 테스트 코드 작성
6. 간단한 문서 정리

이 순서가 바로  
**Agent에게 넘겨줄 일의 설계도**입니다.

---

### Workflow를 Rules와 MCP로 만들기

Workflow는 단순한 체크리스트가 아닙니다.  
**Agent가 반복 실행할 수 있는 구조**여야 합니다.

이를 위해 필요한 것이:
- **Rules** → 사고방식과 기준
- **MCP** → 실제 행동 수단

---

#### Workflow → Rules 변환

예를 들어:

- “보안 먼저 확인한다”  
→ Rule: *모든 입력값은 검증 후 처리*

- “테스트를 작성한다”  
→ Rule: *기능 구현 후 반드시 테스트 코드 생성*

Rules는
> “이 프로젝트에서 항상 지켜야 할 법칙”

입니다.

---

#### Workflow → MCP 변환

사람은 다음과 같이 행동합니다.

- 테스트 실행
- 문서 작성
- 파일 저장

Agent는 이를 위해:
- Test Runner MCP
- File Writer MCP
- Documentation MCP

와 같은 **도구 접근 권한**이 필요합니다.

---

### 내가 일하는 방식대로 Workflow 구성하기 실습

#### 실습 목표

- 나만의 개발 Workflow를 정의한다
- Cursor Agent가 그대로 따라 하게 만든다

---

#### Step 1. 나의 실제 행동 기록하기

최근 작업 하나를 떠올려보세요.

- 어떤 순서로 진행했는가?
- 어떤 판단을 했는가?
- 반복되는 체크 포인트는 무엇인가?

👉 이 단계가 가장 중요합니다.  
AI에게 일을 맡기기 전에 **스스로를 이해해야 합니다.**

---

#### Step 2. 불필요한 판단 제거

AI에게 넘길 Workflow는:
- 모호하면 안 되고
- 감정이 개입되면 안 됩니다

❌ “상황 봐서 적당히”
⭕ “이 기준에 맞으면 진행”

---

### Rules로 Agent에게 명확히 지시하기 실습 (Instruction)

#### 나쁜 Instruction의 예

> “잘 만들어줘”  
> “실무 수준으로 해줘”

이 문장은 사람에게도 불친절합니다.

---

#### 좋은 Instruction의 조건

- 역할(Role)이 명확하다
- 기준(Criteria)이 있다
- 결과물(Output)이 정의되어 있다

---

#### 실습용 Instruction 예시

- 당신은 이 프로젝트의 시니어 개발자입니다
- 아래 Workflow를 반드시 따르세요
- 보안 규칙을 우선시하세요
- 코드 생성 후 스스로 리뷰하세요

👉 이 Instruction은  
**Agent의 행동 성향을 고정**합니다.

---

### Agent가 활용 가능한 Tool 설정하기 실습 (MCP Server)

#### Tool은 권한이다

Agent에게 Tool을 준다는 것은  
**권한을 위임하는 것**입니다.

- 파일 읽기/쓰기
- 테스트 실행
- 문서 생성

따라서 MCP는:
- 최소 권한 원칙
- 목적 기반 접근

을 반드시 지켜야 합니다.

---

#### 실습 예시

- 테스트 실행용 MCP
- 문서 작성용 MCP
- 로그 분석용 MCP

각 MCP는
> “이 Agent는 이 일만 할 수 있다”

라는 경계를 만듭니다.

---

### 나만의 Mode로 상황에 맞는 Model 설정하기 (Custom Mode)

모든 작업에 같은 모델을 쓰는 것은 비효율적입니다.

- 설계 → 고성능 모델
- 단순 수정 → 경량 모델
- 반복 작업 → 빠른 모델

---

#### Custom Mode의 의미

Custom Mode는 단순 설정이 아닙니다.

> **“이 상황에서는 이렇게 행동하는 Agent”**

를 정의하는 것입니다.

- Model
- Temperature
- Tool 사용 여부
- Rule 적용 범위

이 모든 것이 Mode에 포함됩니다.

---

### MCP Server를 활용하여 Task별로 개발하기

이제 개발은 “프로젝트 단위”가 아니라  
**Task 단위**로 나눌 수 있습니다.

- 인증 Task
- 테스트 Task
- 문서 Task

각 Task는:
- 전용 MCP
- 전용 Rules
- 전용 Mode

를 가질 수 있습니다.

👉 이것이 **Agent 기반 분업**입니다.

---

### AI를 활용한 테스트코드 작성하기

테스트 코드는:
- 귀찮지만
- 반드시 필요하고
- 패턴이 반복됩니다

👉 **AI에게 가장 잘 맡길 수 있는 작업**입니다.

Workflow 예:
1. 기능 구현
2. 테스트 기준 전달
3. 테스트 코드 생성
4. 실패 케이스 보완

Agent는
- 놓치기 쉬운 엣지 케이스
- 사람보다 일관된 테스트

를 만들어냅니다.

---

### Cursor에게 문서작업 위임하기

문서는 개발의 부산물이 아닙니다.  
**개발 결과물의 일부**입니다.

Agent에게:
- 코드 요약
- API 문서 생성
- 변경 사항 정리

를 맡기면,
> “문서를 나중에 쓰는 개발”에서  
> “문서가 자동으로 생성되는 개발”로 전환됩니다.

---

### Cursor 고급 기법을 활용한 FrontEnd 개발 실습

프론트엔드 개발은:
- UI 반복
- 상태 관리
- 접근성 고려

등으로 인해 AI 활용 효율이 매우 높습니다.

고급 활용 포인트:
- 컴포넌트 단위 위임
- 접근성 Rule 고정
- 스타일 가이드 Rules화
- Storybook 기반 검증

이 단계에서 Cursor는
> **단순 코딩 도구가 아니라  
> 프론트엔드 팀의 일원**처럼 동작합니다.

---

### 이 섹션의 핵심 정리

- AI에게 일을 맡기려면 먼저 내 일을 구조화해야 한다
- Workflow는 Rules와 MCP로 구현된다
- Instruction은 Agent의 행동을 고정한다
- Tool은 곧 권한이다
- Custom Mode로 상황별 최적화를 한다
- Cursor는 “자동화 도구”가 아니라 **업무 분해 엔진**이다

## 조직에서 AI와 함께 일하기

개인이 AI를 잘 쓰는 것과  
조직이 AI를 잘 쓰는 것은 **전혀 다른 문제**입니다.

개인 단계에서는:
- 빠르면 되고
- 실험적이어도 되고
- 결과만 나오면 됩니다

하지만 조직 단계에서는:
- 누가 써도 같은 결과가 나와야 하고
- 실수가 재현되지 않아야 하며
- 보안과 책임이 명확해야 합니다

이 섹션에서는  
**“AI를 조직의 일원으로 편입시키는 방법”**을 다룹니다.

---

### 개인의 활용과 조직에서의 활용은 무엇이 다를까

#### 개인 활용의 특징

- 즉흥적인 Prompt
- 개인 취향 기반 결과
- 실패해도 개인 책임
- 빠른 실험 가능

👉 개인에게 AI는  
**도구(tool)** 입니다.

---

#### 조직 활용의 특징

- 표준화된 Instruction
- 재현 가능한 Workflow
- 실패 시 조직 전체 리스크
- 보안·감사 대상

👉 조직에게 AI는  
**구성원(member)** 입니다.

---

#### 조직에서 가장 흔한 실패 패턴

- “각자 알아서 쓰세요”
- 개인 Prompt가 난무
- 결과물 품질 편차 극심
- 보안 기준 붕괴

AI를 조직에 도입하면서  
**규칙 없이 자유를 주는 순간**,  
AI는 가장 위험한 변수로 바뀝니다.

---

### 표준 라이브러리 및 프레임워크 정하기  
### (AI에게 개발철학 주입하기)

AI는 “좋은 코드”를 스스로 정의하지 못합니다.  
반드시 **조직의 개발철학**을 주입해야 합니다.

---

#### 왜 개발철학이 중요한가?

같은 기능이라도:
- 어떤 라이브러리를 쓰는지
- 어떤 패턴을 선호하는지
- 어디까지를 책임 범위로 보는지

에 따라 코드가 완전히 달라집니다.

사람은 입사 후 배웁니다.  
AI는 **Instruction으로 즉시 주입해야 합니다.**

---

#### 표준화해야 할 것들

- 프레임워크
  - React / Next.js / NestJS 등
- 상태 관리 방식
- API 통신 규칙
- 테스트 프레임워크
- 에러 처리 방식

이 내용은:
- Wiki
- README
- Rules

로 정리되어야 하며,  
**AI가 항상 참조하는 기준**이 됩니다.

---

#### AI에게 개발철학을 주입하는 Rule 예시

- “이 조직은 단순함을 우선한다”
- “과도한 추상화는 금지한다”
- “테스트가 없는 코드는 미완성이다”

이 문장들은 선언이 아니라  
**Agent의 판단 기준**이 됩니다.

---

### Context의 범위를 제한하기 위한 폴더구조

조직 규모가 커질수록  
AI에게 전체 코드를 맡기는 것은 위험해집니다.

---

#### 문제 상황

- Agent가 연관 없는 파일까지 수정
- 레거시 코드 오염
- 의도하지 않은 사이드 이펙트

이 문제의 원인은 단순합니다.

> **Context가 너무 넓다**

---

#### 폴더 구조는 곧 Context 경계다

AI에게 폴더 구조는:
- 권한 범위
- 책임 영역
- 맥락의 경계

를 의미합니다.

---

#### 조직에 적합한 구조적 전략

- `/core`  
  → 핵심 로직 (AI 수정 제한)

- `/feature/*`  
  → 기능 단위 (Agent 작업 허용)

- `/experimental`  
  → 실험 공간 (자유로운 AI 활용)

이 구조는:
- 사람에게도 명확하고
- AI에게도 안전합니다.

---

### 표준 Workflow를 통한 Rules 공유하기

조직에서 가장 중요한 것은  
**“누가 하느냐”가 아니라 “어떻게 하느냐”**입니다.

---

#### 표준 Workflow란?

- 기능 추가
- 버그 수정
- 리팩토링
- 문서 작성

각 작업에 대해  
**항상 반복되는 순서와 기준**입니다.

---

#### Workflow를 Rules로 고정하기

예:
- 기능 개발 Workflow
  1. 요구사항 요약
  2. 영향 범위 분석
  3. 코드 구현
  4. 테스트
  5. 문서 업데이트

이 Workflow를 Rules로 만들면:
- 모든 Agent
- 모든 개발자

가 **같은 흐름으로 일하게 됩니다.**

---

### 표준 workflow를 통한 MCP Server 관리하기

MCP는 편리하지만,  
조직 차원에서는 **위험 요소**이기도 합니다.

---

#### 조직에서 MCP를 무분별하게 쓰면?

- 각자 다른 MCP 사용
- 보안 통제 불가
- 책임 추적 불가

---

#### 조직 단위 MCP 관리 전략

- 중앙 MCP Registry 운영
- 승인된 MCP만 사용 가능
- Task별 MCP 분리

예:
- `test-mcp`
- `doc-mcp`
- `analysis-mcp`

👉 MCP는 “개인 설정”이 아니라  
**조직 자산**입니다.

---

### Code Rabbit을 통한 Code Review 환경 구성하기

AI를 조직에 도입할 때  
가장 먼저 자동화해야 할 영역은 **Code Review**입니다.

---

#### 왜 Code Review인가?

- 가장 많은 시간이 소요되고
- 품질 편차가 크며
- 시니어 의존도가 높기 때문입니다.

---

#### CodeRabbit의 역할

- PR 단위 Context 이해
- 보안 취약점 탐지
- 컨벤션 위반 지적
- 개선 제안

CodeRabbit은:
- 사람을 대체하지 않습니다
- **사람의 부담을 줄입니다**

---

#### 조직에서의 이상적인 Review 흐름

1. Agent가 코드 생성
2. CodeRabbit 1차 리뷰
3. 사람이 최종 판단

이 구조가 되면:
- 리뷰 품질의 하한선이 올라가고
- 리뷰 문화가 안정됩니다.

---

### 이 섹션의 핵심 정리

- 조직에서 AI는 ‘도구’가 아니라 ‘구성원’이다
- 개발철학은 Rules로 명시해야 한다
- 폴더 구조는 Context 경계다
- Workflow 표준화가 AI 활용의 핵심이다
- MCP는 조직 자산으로 관리해야 한다
- Code Review 자동화는 조직 AI 도입의 출발점이다


## Cursor를 못쓴다면 오픈소스를 써보자

모든 조직이 Cursor를 사용할 수 있는 것은 아닙니다.

- 외부 SaaS 사용이 제한된 환경
- 폐쇄망(망분리) 환경
- 보안 심사가 까다로운 공공·금융 조직

이런 곳에서는 자연스럽게 다음 질문이 나옵니다.

> “Cursor 같은 AI Coding 환경을  
> 오픈소스로도 만들 수 없을까?”

결론부터 말하면 **가능합니다.**  
다만 접근 방식은 조금 달라야 합니다.

---

### 보안이 강화된 환경에서 오픈소스 Coding Tool의 활용

#### 보안 환경의 현실적인 제약

보안이 강화된 조직에서는 다음이 기본 전제입니다.

- 외부 API 호출 제한
- 소스코드 외부 전송 금지
- 로그·프롬프트 감사 대상
- 모델 학습 데이터 통제 필요

즉,
> **“편리함보다 통제 가능성이 우선”**

입니다.

---

#### 오픈소스 기반 접근의 장점

오픈소스 AI Coding Tool은 다음 강점을 가집니다.

- 코드와 동작 방식이 투명
- 네트워크 흐름 통제 가능
- 자체 모델 또는 사내 API 연동 가능
- 보안 감사에 유리

단점도 분명합니다.

- 초기 설정 난이도 높음
- Cursor 대비 UX 부족
- 모델 성능은 직접 책임져야 함

👉 따라서 오픈소스 선택은  
**“대안”이 아니라 “전략적 선택”**입니다.

---

### Cline을 통한 Agent Coding 환경 구성하기

#### Cline이란 무엇인가?

**Cline**은 VS Code 기반의  
오픈소스 **Agent형 AI Coding 도구**입니다.

Cursor와 비교하면:

- UI는 단순하지만
- Agent 개념은 매우 명확하고
- Tool 제어 권한이 강력합니다.

---

#### Cline의 핵심 특징

- 명시적인 Agent 실행
- 파일 접근 / 명령 실행 권한 통제
- 단계별 실행 로그 확인
- 보안 친화적인 설계

Cline은 특히  
**“Agent에게 무엇을 허용할 것인가”**를  
개발자가 명확히 통제할 수 있습니다.

---

#### Cline에서의 Agent Workflow 예시

1. 작업 목표 전달
2. Agent가 계획 수립
3. 파일 수정 요청
4. 실행 전 승인
5. 결과 확인

이 흐름은:
- 느리지만
- 안전하고
- 감사 가능

👉 **보안 환경에서 매우 중요한 특성**입니다.

---

### Cursor 대용으로 Continue 사용하기

#### Continue란 무엇인가?

**Continue**는 VS Code / JetBrains IDE에서 사용 가능한  
오픈소스 AI Coding Assistant입니다.

- Chat 기반 코드 도움
- Inline 코드 수정
- 다양한 LLM 연동 지원

Cursor의 모든 기능을 대체하지는 못하지만,  
**기본적인 AI Coding 경험은 충분히 제공합니다.**

---

#### Continue의 장점

- 설정이 비교적 간단
- 로컬 LLM / 사내 API 연동 용이
- IDE 친화적 UX

#### Continue의 한계

- Agent 개념이 상대적으로 약함
- Workflow / Rules 자동화는 직접 설계 필요

👉 Continue는  
**“협업 중심 AI 도구”**로 적합합니다.

---

### Ollama를 활용한 자체 Model 설정하기

#### 왜 자체 Model이 필요한가?

보안 환경에서 가장 큰 이슈는 항상 이것입니다.

> “우리 코드가 외부로 나가지 않는가?”

이 질문에 가장 확실하게 답하는 방법은  
**모델 자체를 내부에서 돌리는 것**입니다.

---

#### Ollama란 무엇인가?

**Ollama**는 로컬 또는 사내 서버에서  
LLM을 손쉽게 실행할 수 있게 해주는 도구입니다.

- LLaMA 계열
- Mistral
- Code 특화 모델

을 로컬에서 실행 가능

---

#### Ollama 기반 AI Coding 구조 예시

- IDE (VS Code)
- Continue 또는 Cline
- Ollama (로컬 LLM)
- 내부 Git / 테스트 환경

이 구조에서는:
- 코드 외부 유출 ❌
- 네트워크 통제 ⭕
- 로그 감사 ⭕

---

#### 현실적인 한계와 전략

- 최신 상용 모델 대비 성능은 낮을 수 있음
- 대형 코드베이스 이해에는 한계

👉 따라서 실무에서는 다음 전략이 현실적입니다.

- **일반 개발**: 로컬 모델
- **복잡한 설계 / 리뷰**: 제한된 외부 모델
- **최종 결과물**: 내부 검증 필수

---

### 이 섹션의 핵심 정리

- Cursor가 불가능한 환경도 분명 존재한다
- 오픈소스는 보안·통제 측면에서 강력한 대안이다
- Cline은 Agent 중심 보안 환경에 적합하다
- Continue는 가벼운 협업형 AI 도구로 적합하다
- Ollama는 자체 Model 운영의 핵심 인프라다
- 중요한 것은 도구가 아니라 **Agent 설계 철학**이다
